generator client {
  provider = "prisma-client"
  output   = "../src/generated"
}

datasource db {
  provider = "postgresql"
}

//
// ===== Existing core models (kept, but billing/credits are org-first) =====
//

model Language {
  id        String   @id @default(uuid()) @db.Uuid
  value     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  users User[]
}

model User {
  id          String     @id @default(uuid()) @db.Uuid
  clerkUserId String     @unique
  email       String     @unique
  firstName   String?
  lastName    String?
  phone       String?
  languageId  String?    @db.Uuid
  status      UserStatus @default(Active)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @default(now()) @updatedAt

  language          Language?                @relation(fields: [languageId], references: [id])
  memberships       OrganizationMembership[]
  CreditLedgerEntry CreditLedgerEntry[]
}

model OrganizationMembership {
  id             String                     @id @default(uuid()) @db.Uuid
  clerkOrgMemId  String                     @unique
  organizationId String                     @db.Uuid
  userId         String                     @db.Uuid
  role           OrganizationMembershipRole @default(Member)
  createdAt      DateTime                   @default(now())
  updatedAt      DateTime                   @default(now()) @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([userId])
  @@index([organizationId])
}

model Organization {
  id         String   @id @default(uuid()) @db.Uuid
  clerkOrgId String   @unique
  name       String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  memberships OrganizationMembership[]

  // Billing & credits
  subscriptions       OrganizationSubscription[]
  creditBalance       OrganizationCreditBalance?
  creditLedgerEntries CreditLedgerEntry[]
  creditPurchases     OrganizationCreditPurchase[]
  generationJobs      GenerationJob[]
}

enum OrganizationMembershipRole {
  Admin
  Member
}

enum UserStatus {
  Active
  Banned
  Locked
}

//
// ===== Plans (stable identity) + versions (mutable pricing/credits) =====
//

model Plan {
  id String @id @default(uuid()) @db.Uuid

  // Stable identity (unique and not tied to pricing)
  name        String  @unique // e.g. free, coach, pro, academy, federation
  code        String  @unique // can match name; used in code
  isActive    Boolean @default(true)
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  versions      PlanVersion[]
  subscriptions OrganizationSubscription[]
}

model PlanVersion {
  id     String @id @default(uuid()) @db.Uuid
  planId String @db.Uuid

  // Versioning
  effectiveFrom DateTime
  effectiveTo   DateTime?

  // Pricing (can change)
  currency       String  @default("USD")
  priceCents     Int? // null for free/custom-only if you want
  // Allowed billing cycles for this version (stored as flags)
  allowMonthly   Boolean @default(true)
  allowAnnual    Boolean @default(true)
  allowQuarterly Boolean @default(false)

  // Included monthly credits from subscription
  monthlyCreditsIncluded Decimal @default(0) @db.Decimal(18, 6)

  // Rollover policy (monthly credits)
  rolloverEnabled    Boolean  @default(false)
  rolloverMaxCredits Decimal? @db.Decimal(18, 6) // optional cap

  // Daily credits policy (Lovable-like)
  dailyCreditsEnabled    Boolean @default(false)
  dailyCreditsAmount     Decimal @default(0) @db.Decimal(18, 6)
  dailyCreditsMonthlyCap Decimal @default(0) @db.Decimal(18, 6)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  plan             Plan                       @relation(fields: [planId], references: [id], onDelete: Cascade)
  orgSubscriptions OrganizationSubscription[]

  @@index([planId, effectiveFrom])
  @@index([effectiveFrom])
}

//
// ===== Organization subscription (Clerk Billing source of truth) =====
//

model OrganizationSubscription {
  id             String @id @default(uuid()) @db.Uuid
  organizationId String @db.Uuid

  // Plan identity + snapshot via version
  planId        String @db.Uuid
  planVersionId String @db.Uuid

  // Clerk Billing identifiers (subscription-only)
  provider            SubscriptionProvider @default(Clerk)
  clerkSubscriptionId String?              @unique
  clerkPriceId        String? // if you map to a Clerk price object
  status              SubscriptionStatus

  // Billing cycle actually chosen (monthly/annual/quarterly/custom)
  billingInterval BillingInterval

  // Period tracking (useful for renewals + grants)
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  cancelAtPeriodEnd  Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  plan         Plan         @relation(fields: [planId], references: [id])
  planVersion  PlanVersion  @relation(fields: [planVersionId], references: [id])

  @@index([organizationId])
  @@index([planId])
  @@index([planVersionId])
  @@index([status])
}

enum SubscriptionProvider {
  Clerk
  Manual
}

enum SubscriptionStatus {
  Active
  Trialing
  PastDue
  Canceled
  Unpaid
  Incomplete
}

enum BillingInterval {
  Monthly
  Annual
  Quarterly
  Custom
}

//
// ===== Credit packs (Stripe one-off purchases) + versions =====
//

model CreditPack {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @unique // e.g. match_pack, season_pack, tournament_pack
  code        String  @unique
  isActive    Boolean @default(true)
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  versions  CreditPackVersion[]
  purchases OrganizationCreditPurchase[]
}

model CreditPackVersion {
  id           String @id @default(uuid()) @db.Uuid
  creditPackId String @db.Uuid

  effectiveFrom DateTime
  effectiveTo   DateTime?

  currency       String  @default("USD")
  priceCents     Int
  creditsGranted Decimal @db.Decimal(18, 6)

  // Optional expiry policy for purchased credits
  purchasedCreditsExpireDays Int? // null => no expiry

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  creditPack CreditPack                   @relation(fields: [creditPackId], references: [id], onDelete: Cascade)
  purchases  OrganizationCreditPurchase[]

  @@index([creditPackId, effectiveFrom])
}

model OrganizationCreditPurchase {
  id             String @id @default(uuid()) @db.Uuid
  organizationId String @db.Uuid

  creditPackId        String @db.Uuid
  creditPackVersionId String @db.Uuid

  // Stripe identifiers (pack-only)
  stripePaymentIntentId   String  @unique
  stripeChargeId          String?
  stripeCheckoutSessionId String?

  currency    String         @default("USD")
  amountCents Int
  status      PurchaseStatus

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  organization      Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  creditPack        CreditPack          @relation(fields: [creditPackId], references: [id])
  creditPackVersion CreditPackVersion   @relation(fields: [creditPackVersionId], references: [id])
  ledgerEntries     CreditLedgerEntry[]

  @@index([organizationId])
  @@index([creditPackId])
  @@index([creditPackVersionId])
  @@index([status])
}

enum PurchaseStatus {
  Succeeded
  Pending
  Failed
  Refunded
}

//
// ===== Burn rates (feature pricing) + versions =====
//

model BurnRate {
  id          String  @id @default(uuid()) @db.Uuid
  featureKey  String  @unique // e.g. tactical_playbook, ai_audit, pdf_export
  isActive    Boolean @default(true)
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  versions BurnRateVersion[]
  jobs     GenerationJob[]
}

model BurnRateVersion {
  id         String @id @default(uuid()) @db.Uuid
  burnRateId String @db.Uuid

  effectiveFrom DateTime
  effectiveTo   DateTime?

  // Multiplier applied to base units
  multiplier Decimal @default(1.0) @db.Decimal(18, 6)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  burnRate BurnRate @relation(fields: [burnRateId], references: [id], onDelete: Cascade)

  @@index([burnRateId, effectiveFrom])
}

//
// ===== Generation jobs (API -> Pub/Sub -> Worker) =====
//

model GenerationJob {
  id             String @id @default(uuid()) @db.Uuid
  organizationId String @db.Uuid

  // Request context
  featureKey String
  status     JobStatus @default(Queued)

  // Optional trace ids
  requestId       String? @unique
  pubsubMessageId String?

  // Costing
  baseUnits              Decimal  @default(1.0) @db.Decimal(18, 6)
  burnRateId             String?  @db.Uuid
  burnRateVersionId      String?  @db.Uuid
  burnMultiplierSnapshot Decimal? @db.Decimal(18, 6)
  totalCostUnits         Decimal? @db.Decimal(18, 6)

  // Output
  resultRef    String? // e.g. storage key
  errorMessage String?

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt
  startedAt  DateTime?
  finishedAt DateTime?

  organization  Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  burnRate      BurnRate?           @relation(fields: [burnRateId], references: [id])
  ledgerEntries CreditLedgerEntry[]

  @@index([organizationId])
  @@index([status])
  @@index([featureKey])
  @@index([createdAt])
}

enum JobStatus {
  Queued
  Processing
  Succeeded
  Failed
  Canceled
}

//
// ===== Credit ledger (history) + cached balance =====
//

model CreditLedgerEntry {
  id             String @id @default(uuid()) @db.Uuid
  organizationId String @db.Uuid

  idempotencyKey String

  // Amount (+ grant, - burn)
  amount Decimal @db.Decimal(18, 6)

  // Bucket and type
  bucket CreditBucket
  type   CreditEntryType

  // Optional linkage
  jobId      String? @db.Uuid
  purchaseId String? @db.Uuid

  // For audit / UI
  featureKey      String?
  note            String?
  createdByUserId String? @db.Uuid // nullable because system/webhooks also create entries

  createdAt DateTime @default(now())

  organization Organization                @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  job          GenerationJob?              @relation(fields: [jobId], references: [id], onDelete: SetNull)
  purchase     OrganizationCreditPurchase? @relation(fields: [purchaseId], references: [id], onDelete: SetNull)
  createdBy    User?                       @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@unique([organizationId, idempotencyKey])
  @@index([organizationId, createdAt])
  @@index([organizationId, bucket])
  @@index([organizationId, type])
  @@index([jobId])
  @@index([purchaseId])
}

enum CreditBucket {
  Daily
  Subscription
  Purchased
  Rollover
}

enum CreditEntryType {
  // Grants
  GrantMonthly
  GrantDaily
  GrantRollover
  PurchasePack

  // Burns
  BurnDaily
  BurnMonthly
  BurnPurchased

  // Corrections
  RefundPack
  Adjustment
}

model OrganizationCreditBalance {
  id             String @id @default(uuid()) @db.Uuid
  organizationId String @unique @db.Uuid

  // Cached current balances for fast reads
  dailyRemaining     Decimal @default(0) @db.Decimal(18, 6)
  monthlyRemaining   Decimal @default(0) @db.Decimal(18, 6)
  purchasedRemaining Decimal @default(0) @db.Decimal(18, 6)
  rolloverRemaining  Decimal @default(0) @db.Decimal(18, 6)

  // Helpful for daily cap enforcement
  dailyGrantedThisMonth Decimal @default(0) @db.Decimal(18, 6)

  updatedAt DateTime @default(now()) @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([updatedAt])
}
